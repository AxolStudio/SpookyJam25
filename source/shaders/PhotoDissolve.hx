package shaders;

import flixel.math.FlxMath;
import flixel.system.FlxAssets.FlxShader;

@:keep
class PhotoDissolve extends FlxShader
{
	public var dissolve(default, set):Float = 0; // overall dissolve progress
	public var desat(default, set):Float = 0; // desaturate amount 0..1
	public var time(default, set):Float = 0.0;

	@:glFragmentSource('
		#pragma header
		uniform float fDesat;
		uniform float fDissolve;
		uniform float iTime;

		vec3 toGray(vec3 c){ float g = dot(c, vec3(0.299,0.587,0.114)); return vec3(g); }

		void main(){
			vec2 uv = openfl_TextureCoordv;
			vec4 src = flixel_texture2D(bitmap, uv);
			// desaturate instantly for the  ash statue  effect
			vec3 baseGray = mix(src.rgb, toGray(src.rgb), clamp(fDesat,0.0,1.0));

			// Row-stepped dissolve parameters
			const float ROWS = 16.0;
			float vflip = 1.0 - uv.y;
			float rowF = floor(vflip * ROWS);

			// overall progress in rows (0..ROWS). Haxe tween drives fDissolve from 0->1
			float progressed = clamp(fDissolve * ROWS, 0.0, ROWS);
			float currentRow = floor(progressed);
			float local = clamp(progressed - currentRow, 0.0, 1.0);

			// per-row falling: the dissolving row falls more the deeper it is (row index)
			float FALL_PER_ROW = 0.02; // UV units per row step (tweakable)

			// already removed rows
			if (rowF < currentRow) {
				// fully removed rows: output premultiplied-zero to avoid color ghosting
				gl_FragColor = vec4(vec3(0.0), 0.0);
				return;
			}

			// currently dissolving row
			if (rowF == currentRow) {
				// sample from above so the visible pixels appear to fall downwards
				float fall = local * (currentRow + 1.0) * FALL_PER_ROW;
				vec2 sampleUV = uv - vec2(0.0, fall);
				sampleUV.y = clamp(sampleUV.y, 0.0, 1.0);
				vec4 sampled = flixel_texture2D(bitmap, sampleUV);
				vec3 finalCol = mix(sampled.rgb, toGray(sampled.rgb), clamp(fDesat,0.0,1.0));
				float alpha = sampled.a * (1.0 - smoothstep(0.0, 1.0, local));
				// write premultiplied color for a cleaner dissolve (no pasted banding)
				gl_FragColor = vec4(finalCol * alpha, alpha);
				return;
			}

			// rows above currentRow are untouched
			vec4 sampled = flixel_texture2D(bitmap, uv);
			vec3 finalCol = mix(sampled.rgb, toGray(sampled.rgb), clamp(fDesat,0.0,1.0));
			// output premultiplied for consistency
			gl_FragColor = vec4(finalCol * sampled.a, sampled.a);
		}
    ')
	public function new()
	{
		super();
		// initialize uniform fields (generated by @:glFragmentSource)
		try
		{
			dissolve = 0;
		}
		catch (e:Dynamic) {}
		try
		{
			desat = 0;
		}
		catch (e:Dynamic) {}
		try
		{
			time = 0;
		}
		catch (e:Dynamic) {}
	}

	private function set_dissolve(Value:Float):Float
	{
		dissolve = FlxMath.bound(Value, 0, 1);

		try
		{
			fDissolve.value = [dissolve];
		}
		catch (e:Dynamic) {}
		return dissolve;
	}

	private function set_desat(Value:Float):Float
	{
		desat = FlxMath.bound(Value, 0, 1);
		try
		{
			fDesat.value = [desat];
		}
		catch (e:Dynamic) {}
		return desat;
	}

	private function set_time(Value:Float):Float
	{
		time = Value;
		try
		{
			iTime.value = [time];
		}
		catch (e:Dynamic) {}
		return time;
	}
}
